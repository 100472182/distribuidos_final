\documentclass[]{article}
\usepackage{graphicx}
\usepackage[spanish]{babel}
\usepackage[a4paper, top=2.5cm, bottom=2.5cm, left=3cm, right=3cm]{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\usepackage{xcolor}

\lstdefinestyle{mystyle} {
    commentstyle=\color{gray},
    keywordstyle=\color{blue},
    numberstyle=\color{yellow},
    stringstyle=\color{pink},
    breaklines=true,
    breakatwhitespace=false,
    captionpos=b,
    keepspaces=true,
    numbers=none,
    numbersep=5pt,
    showspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=mystyle}

%title
\title{Práctica 1} 

\author{Adrián Ferández Galán y César López Mantecón}

\begin{document}

\begin{titlepage}
    \centering
   \includegraphics[width=0.9\textwidth]{uc3m.jpg} 
    {\Huge Universidad Carlos III\\
    
     \Large Sistemas Distribuidos\\
     \vspace{0.5cm}
     Curso 2023-24}
    \vspace{2cm}

    {\Huge \textbf{Práctica Final} \par}
    \vspace{0.5cm}
    {\Large Diseño e implementación de un sistema peer-to-peer \par}
    \vspace{8cm}

   \textbf{Ingeniería Informática, Tercer curso}\\
    \vspace{0.2cm} 
    Adrián Fernández Galán (NIA: 100472182, e-mail: 100472182@alumnos.uc3m.es) \\
    César López Mantecón   (NIA: 100472092, e-mail: 100472092@alumnos.uc3m.es)
    \vspace{0.5cm}

   
    \textbf{Prof .} Félix García Caballeira y Alejandro Calderón Mateos\\
    
    \textbf{Grupo: } 81   
    
\end{titlepage}
\newpage

\renewcommand{\contentsname}{\centering Índice}
\tableofcontents

\newpage

\section{Introducción}
\label{sec:introduccion}
En este documento se recoge el desarrollo de la práctica final de Sistemas Distribuidos. Para esta práctica hemos desarrollado una aplicación distribuida que cuenta con 2 servidores desarrollados en lenguaje C, un código clinete desarrollado en python y un servicio web desarrollado igualmente en Python. A continuación describiremos el diseño e implementación de cada una de las partes del sistema. 
\section{Diseño original}
\label{sec:disenno}
La aplicación constará de dos partes diferenciadas: los clientes y el servidor.

\subsection{Cliente}
\label{subsec:cliente}
Los servicios proporcionados por la aplicación se podrán utilizar a través de los clientes programados en \textit{Python}.
Para ello los clientes tendrán una interfaz de comandos con la que podrán acceder a las distintas funcionalidades:
\begin{itemize}
  \item \textbf{REGISTER}: Este mandato permitirá al usuario crearse una nueva cuenta en nuestra aplicación
  \item \textbf{UNREGISTER}: Este mandato permitirá al usuario borrar su cuenta de nuestra aplicación
  \item \textbf{CONNECT}: Este mandato permitirá al usuario conectarse a la aplicación, por lo que dispondrá del resto de funcionalidades
  \item \textbf{DISCONNECT}: Este mandato permitirá al usuario desconectarse de la aplicación, perdiendo el acceso al resto de funcionalidades
  \item \textbf{PUBLISH}: Este mandato permitirá al usuario publicar un archivo para que sea visible al resto de clientes. Para ello proporcionará un \textit{path} absoluto del fichero
  \item \textbf{DELETE}: Este mandato permitirá al usuario borrar un archivo publicado anteriormente
  \item \textbf{LIST\_USERS}: Este mandato permitirá al usuario conocer cuales son los usuarios que están conectados
  \item \textbf{LIST\_CONTENT}: Este mandato permitirá al usuario conocer los archivos publicados por el usuario proporcionado
  \item \textbf{GET\_FILE}: Este mandato permitirá al usuario obtener un archivo publicado por otro usuario
\end{itemize}

Cabe destacar que al realizar el comando \textbf{CONNECT} se creará un nuevo hilo por parte del cliente para atender peticiones de otros clientes sobre los ficheros publicados. De esta manera el cliente tendrá un hilo que siga utilizando la interfaz de comandos mientras que otro hilo dará soporte a las peticiones de otros clientes.

\subsection{Servidor}
\label{subsec:servidor}
El servidor implementa los servicios necesarios para la coordinación de clientes. Para esto se apoya en una estructura de implementación propia especialmente diseñada para las particularidades de la práctica. 

\subsubsection{Implementación en el servidor}
\label{subsec:implementacion_servidor}
Se ha implementado una estructura de datos para representar la lista de usuarios registrados en el sistema. Para cada usuario se almacena su nombre, los archivos que tiene publicados, su ip, su puerto y si está o no conectado. La estructura empleada es la siguiente: 

\begin{lstlisting}[language=C]
#define CHARSIZE 512

typedef struct {
    char name[CHARSIZE];
    char description[CHARSIZE];

} file;

typedef struct {
    char name[CHARSIZE];
    file* contents;
    int contentsLen;
    int contentsMaxLen;
    int conected;
    int port;
    char ip[32];

} user;

\end{lstlisting}

Dado que pueden haber un número indefinido de usuarios registrados, y que cada usuario puede tener publicados un número cualquiera de ficheros, se ha optado porque la estructura doble su tamaño cada vez que sea necesario relocalizar la memoria.

Para el manejo de la estructura se ha implementado la siguiente interfaz de funciones: 

\begin{itemize}
  \item \texttt{createUserList()}: Esta función crea una lista de usuarios vacía.
  \item \texttt{searchUser()}: Esta función busca un usuario en la lista.
  \item \texttt{addUser()}: Esta función añade un nuevo usuario en el caso de que no exista ya.
  \item \texttt{removeUser()}: Esta función borra al usuario si existe en la lista.
  \item \texttt{addContent()}: Esta función añade nuevo contenido a un usuario existente.
  \item \texttt{removeContent()}: Esta función borra contenido a un usuario existente.
  \item \texttt{destroyList()}: Esta función borra la lista de usuarios por completo.
\end{itemize}

\subsubsection{Concurrencia del Servidor}
\label{subsec::concurrencia_servidor}
El servidor atiende clientes de manera concurrente. Para esto hemos optado por una aproximación de hilos bajo demanda. Es decir, cada vez que el servidor recibe una petición creará y lanzará un hilo \textit{detached} para el tratamiento de la misma. Con esto, son necesarios dos requisitos: detener al hilo principal para que no reciba una nueva petición hasta que el hilo haya copiado la anterior y asegurar el acceso exclusivo a la estructura definida en el apartado anterior. 

Para lo primero, al igual que en la práctica dos, hacemos uso de un mutex y una condición que bloqueal al hilo principal hasta que el hilo haya copiado el descriptor, ip y puerto del cliente conectado. 

Para asegurar el acceso exclusivo a la estructura de datos y, así, evitar condiciones de carrera, hacemos uso de un segundo mutex que protege cualqueir sección de código que acceda a la lista de usuarios. 

\subsection{Comunicación}
\label{subsec:comunicacion}
La comunicación entre los distintos clientes y el servidor ocurre de manera independiente a las distintas máquinas que se conectan a nuestro servicio a través de sockets. Para conseguir esto hemos codificado todas las comunicaciones en cadeanas de caracterres, a excepción del valor de retorno de las operaciones. Además, para evitar problemas ocasionados por el ordenamiento de bytes enviamos un único carácter a la vez. 

La comunicación será una comunicación por petición, por lo que se abrirá la conexión con el servidor para realizar la petición correspondiente y, si todo ha funcionado correctamente, se cerrará la conexión.

\subsubsection{Funciones auxiliares para la comunicación}
\label{subsec:funciones}
Para facilitar la implementación de la comunicación mediante \textit{sockets} se han implementado una serie de funciones auxiliares recogidas en el fichero \textit{src/servidor/common.c}. Estas implementan acciones repetidas en el lado servidor, así como gestión de errores y envío y recepción de mensajes adaptados a las necesidades del sistema. 

\begin{itemize}
    \item \texttt{serverSocket()}: crea y devuelve un \textit{socket} para el servidor en un número de puerto dado. Además, se ejecuta la llamada \texttt{listen()} para permitir al servidor aceptar conexiones más adelante. 
    \item \texttt{serverAccept()}: esta función permite al servidor aceptar una conexión con un cliente. 
    \item \texttt{clientSocket()}: crea y devuelve un socket para un cliente en el sistema. Además, este \textit{socket} estará conectado al servidor. 
    \item \texttt{sendMessage()}: envía un mensaje contenido en un \textit{buffer} a través de un \textit{socket}. 
    \item \texttt{recvMessage()}: recibe un mensaje y lo almacena en n \textit{buffer} dado. 
    \item \texttt{writeline()}: se apoya de la función \texttt{sendMessage()} para enviar un mensaje hasta el final de cadena.
    \item \texttt{readLine()}: se apoya de \texttt{recvMessage()} para recibir un menesaje hasta el final de la cadena de texto.
\end{itemize}

\section{Servicio web}
\label{sec:web_service}
Se ha desarrollado un servcio web en \textit{Python} que proporciona la fecha y la hora en la que se realizó la petición al servicio web.
Este servicio web se llamará desde el lado del cliente cada vez que se quiera realizar un llamada a algún servicio de la aplicación, y se mandarán al servidor junto al resto de datos necesarios.

\section{Integración del servidor RPC}
\label{sec:rpc}
Describir aquí como hemos integrado el servidor y las modificaciones necesarias en el código 

\section{Compilación}
\label{sec:compilacion}
En esta sección nos centraremos en la forma de compilar los servidores, ya que son la única parte del código escrita en un lenguaje compilado. La compilación del proyecto está contenida en un fichero \textit{Makefile} situado en la raiz del proyecto.  

El código necesario para el servidor está distrbuído en varios ficheros. Primero, el código encargado de la gestión de la comunicación con los clientes python y la ejecución de los servicios se encuentra contenido en el fichero \textit{src/servidor/servidor.c}; segundo, el código que encapsula la funcionalidad de la estructura de datos se encuentra en el fichero \textit{src/servidor/server\_storage.c}; y, por último, el código para la invocación de los procesos remotos se encuentra en el fichero \textit{print\_clnt.c} generado a través del comando \texttt{rpcgen}.Para generar el ejecutable correcatmente hemos compilado cada uno de estos ficheros por separado con las opciones de compilación adecuadas para crear varios ficheros objeto; después hemos enlazado estos ficheros en la generación del ejecutable \textit{servidor}.

El código del servidor RPC está contenido exclusivamente en los ficheros \textit{print\_svc.c} y \textit{print\_server.c}. De nuevo, compilaremos estos dos ficheros de manera separada para luego enlazarlos.

A continuación se muestran los comandos necesarios para generar los ficheros objeto:

\begin{center}
  \begin{lstlisting}[caption=Compilación de ficheros en ficheros objetos, language=bash]
    # generacion de objeto de la implementacion
    gcc -c src/servidor/server_storage.c
    
    # generacion de objeto de funciones auxiliares
    gcc -c src/servidor/common.c

    # generacion de objetos de archivos rpc
    gcc -g -I/usr/include/tirpc -D_REENTRANT -o print_clnt.o -c src/rpc/print_clnt.c
    gcc -g -I/usr/include/tirpc -D_REENTRANT -o print_svc.o -c src/rpc/print_svc.c

    # generacion de objeto de servidores
    gcc -c servidor.c
    gcc -g -I/usr/include/tirpc -c src/rpc/print_server.c
    
    \end{lstlisting}
\end{center}

Y con el siguiente fragmento del fichero \textit{Makefile} se enlazan los ficheros y se generan ambos ejecutables con los nombres \textit{servidor} y \textit{servidor\_rpc}:

\begin{center}
  \begin{lstlisting}[caption=Generación de ejecutables, language=bash]
    # generacion de ejecutable del servidor
    gcc -g -Wall -lrt -o servidor servidor.o server_storage.o common.o print_clnt.o -lnsl -lpthread -ldl -ltirpc
    
    # generacion de ejecutable del servidor rpc
    gcc -g -Wall -lrt -o servidor_rpc print_server.o print_svc.o -lnsl -lpthread -ldl -ltirpc

    \end{lstlisting}
\end{center}

\section{Descripción de pruebas}
\label{sec:descripcion_de_pruebas}
Descripción de pruebas 

\section{Conclusiones}
\label{sec:conclusiones}
Este ejercicio combina casi todas las tecnologías que se nos han presentado durante el curso en un sistema completo que pretende aproximarse a una aplicación distribuída. Esto nos ha permitido afianzar los conocimientos adquiridos en la asignatura y desarrollar nuestras competencias para la programación de servicios distribuidos. 

Además, esta práctica nos presenta por primera vez la necesidad de integrar nuevos servicios basados en otra tecnología sobre un sistema ya funcional. Esta es una aptitud verdaderamente interesante y valiosa de cara a nuestro desarrollo como informáticos.
\end{document}
